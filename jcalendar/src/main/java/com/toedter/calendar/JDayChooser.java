/*
 * Copyright (C) 2019 Ruslan Lopez Carro.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */
package com.toedter.calendar;

import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.UIManager;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.text.DateFormatSymbols;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;

/**
 * JDayChooser is a bean for choosing a day.
 *
 * @author Ruslan LÃ³pez Carro
 * @author Kai Toedter
 * @version $LastChangedRevision: 107 $
 * @version $LastChangedDate: 2009-05-01 15:48:00 +0200 (Fr, 01 Mai 2009) $
 */
public class JDayChooser extends JPanel implements ActionListener, KeyListener,
        FocusListener {

    private static final long serialVersionUID = 5876398337018781820L;
    private static final int DAYS_IN_WEEK = 7;
    private static final int SATURDAY_INDEX = 5;
    private static final int SUNDAY_INDEX = 6;
    private static final int DAYS_SLOTS = 49;

    /* GUI Colors */
    protected Color sundayForeground;

    protected Color weekdayForeground;

    protected Color decorationBackgroundColor;

    protected Color oldDayBackgroundColor;

    protected Color selectedColor;

    protected int day;
    protected String[] dayNames;

    protected JButton[] days;
    protected JButton selectedDay;
    protected JButton[] weeks;

    protected boolean weekOfYearVisible;

    protected Locale locale;

    /*Date related variables*/
    protected Calendar calendar;

    protected Calendar today;

    protected Date minSelectableDate;

    protected Date maxSelectableDate;

    protected Date defaultMinSelectableDate;

    protected Date defaultMaxSelectableDate;

    protected DateVerifier dateVerifier;

    /* configuration section */
    private boolean alwaysFireDayProperty;
    protected boolean initialized;
    protected int maxDayCharacters;

    protected List<IDateEvaluator> dateEvaluators;

    protected MinMaxDateEvaluator minMaxDateEvaluator;

    protected boolean decorationBordersVisible;
    protected boolean dayBordersVisible;
    protected boolean decorationBackgroundVisible = true;


    // Variables declaration - do not modify//GEN-BEGIN:variables
    protected JPanel dayPanel;
    protected JPanel weekPanel;
    // End of variables declaration//GEN-END:variables

    /**
     * Default JDayChooser constructor.
     */
    public JDayChooser() {
        this(false);
    }

    /**
     * JDayChooser constructor.
     *
     * @param weekOfYearVisible true, if the weeks of a year shall be shown
     */
    public JDayChooser(boolean weekOfYearVisible) {
        this.weekOfYearVisible = weekOfYearVisible;
        locale = Locale.getDefault();
        calendar = Calendar.getInstance(locale);
        today = (Calendar) calendar.clone();

        sundayForeground = new Color(164, 0, 0);
        weekdayForeground = new Color(0, 90, 164);

        // decorationBackgroundColor = new Color(194, 211, 252);
        // decorationBackgroundColor = new Color(206, 219, 246);
        decorationBackgroundColor = new Color(210, 228, 238);

        Calendar tmpCalendar = Calendar.getInstance();
        tmpCalendar.set(1, Calendar.JANUARY, 1, 1, 1);
        defaultMinSelectableDate = tmpCalendar.getTime();
        minSelectableDate = defaultMinSelectableDate;
        tmpCalendar.set(9999, Calendar.JANUARY, 1, 1, 1);
        defaultMaxSelectableDate = tmpCalendar.getTime();
        maxSelectableDate = defaultMaxSelectableDate;

        initComponents();
        initialized = true;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        initializeDateEvaluators();
        weekPanel = new JPanel();
        fillWeekPanel();
        dayPanel = new JPanel();
        fillDayPanel();

        weekPanel.setLayout(new GridLayout(7, 1));

        setBackground(Color.blue);
        setName("JDayChooser"); // NOI18N
        setLayout(new BorderLayout());

        dayPanel.setLayout(new GridLayout(7, 7));

        init();
        setDay(Calendar.getInstance().get(Calendar.DAY_OF_MONTH));
        if (weekOfYearVisible) {
            add(weekPanel, BorderLayout.WEST);
        }
        updateUI();

        add(dayPanel, BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Initializes the locale specific names for the days of the week.
     */
    protected void init() {
        getOldDayColor();
        selectedColor = new Color(160, 160, 160);
        setCalendarLocale();
        drawDayNames();
        drawDays();
    }

    private void getOldDayColor() {
        final JButton testButton = new JButton();
        oldDayBackgroundColor = testButton.getBackground();
    }

    private void setCalendarLocale() {
        final Date date = calendar.getTime();
        calendar = Calendar.getInstance(locale);
        calendar.setTime(date);
    }

    /**
     * Draws the day names of the day columns.
     */
    private void drawDayNames() {
        int firstDayOfWeek = calendar.getFirstDayOfWeek();
        getDayNames();

        int aDay = firstDayOfWeek;

        for (int i = 0; i < DAYS_IN_WEEK; i++) {
            if (maxDayCharacters > 0 && maxDayCharacters < 5 && dayNames[aDay].length() >= maxDayCharacters) {
                dayNames[aDay] = dayNames[aDay]
                        .substring(0, maxDayCharacters);
            }

            days[i].setText(dayNames[aDay]);

            if (aDay == 1) {
                days[i].setForeground(sundayForeground);
            } else {
                days[i].setForeground(weekdayForeground);
            }

            if (aDay < 7) {
                aDay++;
            } else {
                aDay -= SUNDAY_INDEX;
            }
        }
    }

    private void getDayNames() {
        DateFormatSymbols dateFormatSymbols = new DateFormatSymbols(locale);
        dayNames = dateFormatSymbols.getShortWeekdays();
    }

    /**
     * Hides and shows the day buttons.
     */
    protected void drawDays() {
        Calendar tmpCalendar = (Calendar) calendar.clone();
        tmpCalendar.set(Calendar.HOUR_OF_DAY, 0);
        tmpCalendar.set(Calendar.MINUTE, 0);
        tmpCalendar.set(Calendar.SECOND, 0);
        tmpCalendar.set(Calendar.MILLISECOND, 0);

        Calendar minCal = Calendar.getInstance();
        minCal.setTime(minSelectableDate);
        minCal.set(Calendar.HOUR_OF_DAY, 0);
        minCal.set(Calendar.MINUTE, 0);
        minCal.set(Calendar.SECOND, 0);
        minCal.set(Calendar.MILLISECOND, 0);

        Calendar maxCal = Calendar.getInstance();
        maxCal.setTime(maxSelectableDate);
        maxCal.set(Calendar.HOUR_OF_DAY, 0);
        maxCal.set(Calendar.MINUTE, 0);
        maxCal.set(Calendar.SECOND, 0);
        maxCal.set(Calendar.MILLISECOND, 0);

        int firstDayOfWeek = tmpCalendar.getFirstDayOfWeek();
        tmpCalendar.set(Calendar.DAY_OF_MONTH, 1);

        int firstDay = tmpCalendar.get(Calendar.DAY_OF_WEEK) - firstDayOfWeek;

        if (firstDay < 0) {
            firstDay += 7;
        }

        hideDaysBeforeFirstDay(firstDay);




        int daysOfMonth = getDaysOfMonth(tmpCalendar, minCal, maxCal, firstDay);
        hideInvalidDays(daysOfMonth, firstDay);
        drawWeeks();
    }

    private int getDaysOfMonth(Calendar tmpCalendar, Calendar minCal, Calendar maxCal, int firstDay) {
        Color foregroundColor = getForeground();
        Date firstDayInNextMonth = getFirstDayInNextMonth(tmpCalendar);

        Date aDay = tmpCalendar.getTime();
        int dayNumber = 0;
        while (aDay.before(firstDayInNextMonth)) {
            JButton b = days[firstDay + dayNumber + 7];
            b.setText(Integer.toString(dayNumber + 1));
            b.setVisible(true);

            if ((tmpCalendar.get(Calendar.DAY_OF_YEAR) == today
                    .get(Calendar.DAY_OF_YEAR))
                    && (tmpCalendar.get(Calendar.YEAR) == today
                    .get(Calendar.YEAR))) {
                b.setForeground(sundayForeground);
            } else {
                b.setForeground(foregroundColor);
            }

            if ((dayNumber + 1) == this.day) {
                assignSelectedDay(b, null);
//				b.setBackground(selectedColor);
//				selectedDay = b;
            } else {
                assignSelectedDay(null, b);
            }

            if (tmpCalendar.before(minCal) || tmpCalendar.after(maxCal)) {
                b.setEnabled(false);
            } else {

                if (dateVerifier != null) {
                    b.setEnabled(!dateVerifier.isInvalid(new Date(tmpCalendar.getTimeInMillis())) && isEnabled());
                } else {
                    b.setEnabled(isEnabled());
                }

            }

            //            days[i + n + 7].setEnabled(true);

//            Iterator iterator = dateEvaluators.iterator();

//            while (iterator.hasNext()) {
//                IDateEvaluator dateEvaluator = (IDateEvaluator) iterator.next();
//                if (dateEvaluator.isSpecial(day)) {
//                    days[i + n + 7].setForeground(dateEvaluator
//                            .getSpecialForegroundColor());
//                    days[i + n + 7].setBackground(dateEvaluator
//                            .getSpecialBackroundColor());
//                    days[i + n + 7].setToolTipText(dateEvaluator.getSpecialTooltip());
//                    days[i + n + 7].setEnabled(true);
//                }
//                if (dateEvaluator.isInvalid(day)) {
//                    days[i + n + 7].setForeground(dateEvaluator
//                            .getInvalidForegroundColor());
//                    days[i + n + 7].setBackground(dateEvaluator
//                            .getInvalidBackroundColor());
//                    days[i + n + 7].setToolTipText(dateEvaluator.getInvalidTooltip());
//                    days[i + n + 7].setEnabled(false);
//                }
//            }

            dayNumber++;
            tmpCalendar.add(Calendar.DATE, 1);
            aDay = tmpCalendar.getTime();
        }
        return dayNumber;
    }

    private Date getFirstDayInNextMonth(Calendar tmpCalendar) {
        tmpCalendar.add(Calendar.MONTH, 1);
        Date firstDayInNextMonth = tmpCalendar.getTime();
        tmpCalendar.add(Calendar.MONTH, -1);
        return firstDayInNextMonth;
    }

    private void hideDaysBeforeFirstDay(int firstDay) {
        for (int currentDay = 0; currentDay < firstDay; currentDay++) {
            days[currentDay + 7].setVisible(false);
            days[currentDay + 7].setText("");
        }
    }

    private void hideInvalidDays(int daysOfMonth, int firstDay) {
        for (int dayNumber = daysOfMonth + firstDay + 7; dayNumber < DAYS_SLOTS; dayNumber++) {
            days[dayNumber].setVisible(false);
            days[dayNumber].setText("");
        }
    }

    /**
     * Hides and shows the week buttons.
     */
    protected void drawWeeks() {
        final Calendar tmpCalendar = (Calendar) calendar.clone();

        for (int i = 1; i < DAYS_IN_WEEK; i++) {
            tmpCalendar.set(Calendar.DAY_OF_MONTH, (i * DAYS_IN_WEEK) - SUNDAY_INDEX);

            int week = tmpCalendar.get(Calendar.WEEK_OF_YEAR);
            StringBuilder buttonText = new StringBuilder(Integer.toString(week));

            if (week < 10) {
                buttonText.insert(0, "0");
            }

            weeks[i].setText(buttonText.toString());

            if ((i == SATURDAY_INDEX) || (i == SUNDAY_INDEX)) {
                weeks[i].setVisible(days[i * DAYS_IN_WEEK].isVisible());
            }
        }
    }

    private void fillDayPanel() {
        days = new JButton[DAYS_SLOTS];
        for (int y = 0; y < 7; y++) {
            for (int x = 0; x < 7; x++) {
                int index = x + (7 * y);

                if (0 == y) {
                    days[index] = new DecoratorButton(decorationBackgroundColor, decorationBackgroundVisible, decorationBordersVisible, sundayForeground);
                } else {
                    days[index] = new JButton("x") {
                        private static final long serialVersionUID = -7433645992591669725L;

                        @Override
                        public void paint(Graphics g) {
                            // this is a hack to get the background painted
                            // when using Windows Look & Feel
                            if ("Windows".equals(UIManager.getLookAndFeel()
                                    .getID()) && selectedDay == this) {
                                g.setColor(selectedColor);
                                g.fillRect(0, 0, getWidth(), getHeight());
                            }
                            super.paint(g);
                        }

                    };
                    days[index].addActionListener(this);
                    days[index].addKeyListener(this);
                    days[index].addFocusListener(this);
                }

                days[index].setMargin(new Insets(0, 0, 0, 0));
                days[index].setFocusPainted(false);
                dayPanel.add(days[index]);
            }
        }
    }

    private void fillWeekPanel() {
        weeks = new JButton[7];

        for (int i = 0; i < 7; i++) {
            weeks[i] = new DecoratorButton(decorationBackgroundColor, decorationBackgroundVisible, decorationBordersVisible, sundayForeground);
            weeks[i].setMargin(new Insets(0, 0, 0, 0));
            weeks[i].setFocusPainted(false);
            weeks[i].setForeground(new Color(100, 100, 100));

            if (0 != i) {
                weeks[i].setText("0" + (i + 1));
            }

            weekPanel.add(weeks[i]);
        }
    }

    private void assignSelectedDay(JButton selectedDay, JButton other) {
        if (this.selectedDay != null && selectedDay != null) {
            this.selectedDay.setOpaque(false);
            this.selectedDay.setBackground(oldDayBackgroundColor);
        }

        if (selectedDay != null) {
            selectedDay.setOpaque(true);
            selectedDay.setBackground(selectedColor);
            this.selectedDay = selectedDay;
        }

        if (other != null) {
            other.setOpaque(false);
            other.setBackground(oldDayBackgroundColor);
        }
    }

    /**
     * Sets the day. This is a bound property.
     *
     * @param someDay the day
     *
     * @see #getDay
     */
    public void setDay(int someDay) {

        Calendar tmpCalendar = (Calendar) calendar.clone();
        tmpCalendar.set(Calendar.DAY_OF_MONTH, 1);
        tmpCalendar.add(Calendar.MONTH, 1);
        tmpCalendar.add(Calendar.DATE, -1);

        int maxDaysInMonth = tmpCalendar.get(Calendar.DATE);

        int d = Math.min(Math.max(someDay, 1), maxDaysInMonth);

        int oldDay = day;
        day = d;

//		if (selectedDay != null) {
//			selectedDay.setBackground(oldDayBackgroundColor);
//			selectedDay.repaint();
//		}
        for (int i = 7; i < DAYS_SLOTS; i++) {
            if (days[i].getText().equals(Integer.toString(day))) {
                assignSelectedDay(days[i], null);
                break;
            }
        }

        if (alwaysFireDayProperty) {
            firePropertyChange("day", 0, day);
        } else {
            firePropertyChange("day", oldDay, day);
        }
    }

    /**
     * Returns the selected day.
     *
     * @return the day value
     *
     * @see #setDay
     */
    public int getDay() {
        return day;
    }

    /**
     * JDayChooser is the ActionListener for all day buttons.
     *
     * @param e the ActionEvent
     */
    @Override
    public void actionPerformed(ActionEvent e) {
        JButton button = (JButton) e.getSource();
        String buttonText = button.getText();
        int tDay = Integer.parseInt(buttonText);
        setDay(tDay);
    }

    /**
     * Does nothing.
     *
     * @param e the KeyEvent
     */
    @Override
    public void keyTyped(KeyEvent e) {
        // no need at the moment
    }

    /**
     * JDayChooser is the KeyListener for all day buttons. (Added by Thomas
     * Schaefer and modified by Austin Moore)
     *
     * @param e the KeyEvent
     */
    @Override
    public void keyPressed(KeyEvent e) {
        int offset = (e.getKeyCode() == KeyEvent.VK_UP) ? (-7) : ((e
                .getKeyCode() == KeyEvent.VK_DOWN) ? (+7)
                        : ((e.getKeyCode() == KeyEvent.VK_LEFT) ? (-1) : ((e
                        .getKeyCode() == KeyEvent.VK_RIGHT) ? (+1) : 0)));

        int newDay = getDay() + offset;

        if ((newDay >= 1)
                && (newDay <= calendar.getMaximum(Calendar.DAY_OF_MONTH))) {
            setDay(newDay);
        }
    }

    /**
     * Does nothing.
     *
     * @param e the KeyEvent
     */
    @Override
    public void keyReleased(KeyEvent e) {
        // no need at the moment
    }

    /**
     * JDayChooser is the FocusListener for all day buttons. (Added by Thomas
     * Schaefer)
     *
     * @param e the FocusEvent
     */
    /*
	 * Code below commented out by Mark Brown on 24 Aug 2004. This code breaks
	 * the JDateChooser code by triggering the actionPerformed method on the
	 * next day button. This causes the date chosen to always be incremented by
	 * one day.
     */
    @Override
    public void focusGained(FocusEvent e) {
        // JButton button = (JButton) e.getSource();
        // String buttonText = button.getText();
        //
        // if ((buttonText != null) && !buttonText.equals("") &&
        // !e.isTemporary()) {
        // actionPerformed(new ActionEvent(e.getSource(), 0, null));
        // }
    }

    /**
     * Does nothing.
     *
     * @param e the FocusEvent
     */
    @Override
    public void focusLost(FocusEvent e) {
        // no need at the moment
    }

    /**
     * Returns the locale.
     *
     * @return the locale value
     *
     * @see #setLocale
     */
    @Override
    public Locale getLocale() {
        return locale;
    }

    /**
     * Sets the locale.
     *
     * @param locale the new locale value
     *
     * @see #getLocale
     */
    @Override
    public void setLocale(Locale locale) {
        if (!initialized) {
            super.setLocale(locale);
        } else {
            this.locale = locale;
            super.setLocale(locale);
            init();
        }
    }

    /**
     * Initializes both day names and weeks of the year.
     */
    protected void initDecorations() {
        for (int x = 0; x < 7; x++) {
            days[x].setContentAreaFilled(decorationBackgroundVisible);
            days[x].setBorderPainted(decorationBordersVisible);
            days[x].invalidate();
            days[x].repaint();
            weeks[x].setContentAreaFilled(decorationBackgroundVisible);
            weeks[x].setBorderPainted(decorationBordersVisible);
            weeks[x].invalidate();
            weeks[x].repaint();
        }
    }

    /**
     * this is needed for JDateChooser.
     *
     * @param alwaysFire true, if day property shall be fired every time a day
     * is chosen.
     */
    public void setAlwaysFireDayProperty(boolean alwaysFire) {
        alwaysFireDayProperty = alwaysFire;
    }

    /**
     * Sets a specific month. This is needed for correct graphical
     * representation of the days.
     *
     * @param month the new month
     */
    public void setMonth(int month) {
        calendar.set(Calendar.MONTH, month);
        int maxDays = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);

        int adjustedDay;
        if (day > maxDays) {
            adjustedDay = maxDays;
            setDay(adjustedDay);
        }

        drawDays();
    }

    /**
     * Sets a specific year. This is needed for correct graphical representation
     * of the days.
     *
     * @param year the new year
     */
    public void setYear(int year) {
        calendar.set(Calendar.YEAR, year);
        drawDays();
    }

    /**
     * Sets a specific calendar. This is needed for correct graphical
     * representation of the days.
     *
     * @param calendar the new calendar
     */
    public void setCalendar(Calendar calendar) {
        this.calendar = (Calendar) calendar.clone();
        drawDays();
    }

    /**
     * Sets the font property.
     *
     * @param font the new font
     */
    @Override
    public void setFont(Font font) {
        if (days != null) {
            for (int dayNumber = 0; dayNumber < DAYS_SLOTS; dayNumber++) {
                days[dayNumber].setFont(font);
            }
        }
        if (weeks != null) {
            for (int weekNumber = 0; weekNumber < 7; weekNumber++) {
                weeks[weekNumber].setFont(font);
            }
        }
    }

    /**
     * Sets the foregroundColor color.
     *
     * @param foreground the new foregroundColor
     */
    @Override
    public void setForeground(Color foreground) {
        super.setForeground(foreground);

        if (days != null) {
            for (int dayNumber = 7; dayNumber < DAYS_SLOTS; dayNumber++) {
                days[dayNumber].setForeground(foreground);
            }

            drawDays();
        }
    }

    /**
     * Enable or disable the JDayChooser.
     *
     * @param enabled The new enabled value
     */
    @Override
    public void setEnabled(boolean enabled) {
        super.setEnabled(enabled);

        if (enabled) {
            drawDays();
        } else {
            for (JButton jButton : days) {
                if (jButton != null) {
                    jButton.setEnabled(false);
                }
            }
        }

        for (JButton week : weeks) {
            if (week != null) {
                week.setEnabled(enabled);
            }
        }
    }

    /**
     * In some Countries it is often useful to know in which week of the year a
     * date is.
     *
     * @return boolean true, if the weeks of the year is shown
     */
    public boolean isWeekOfYearVisible() {
        return weekOfYearVisible;
    }

    /**
     * In some Countries it is often usefull to know in which week of the year a
     * date is.
     *
     * @param weekOfYearVisible true, if the weeks of the year shall be shown
     */
    public void setWeekOfYearVisible(boolean weekOfYearVisible) {
        if (weekOfYearVisible == this.weekOfYearVisible) {
            return;
        } else if (weekOfYearVisible) {
            add(weekPanel, BorderLayout.WEST);
        } else {
            remove(weekPanel);
        }

        this.weekOfYearVisible = weekOfYearVisible;
        validate();
        dayPanel.validate();
    }

    /**
     * Returns the day panel.
     *
     * @return the day panel
     */
    public JPanel getDayPanel() {
        return dayPanel;
    }

    /**
     * Returns the color of the decoration (day names and weeks).
     *
     * @return the color of the decoration (day names and weeks).
     */
    public Color getDecorationBackgroundColor() {
        return decorationBackgroundColor;
    }

    /**
     * Sets the background of days and weeks of year buttons.
     *
     * @param decorationBackgroundColor The background to set
     */
    public void setDecorationBackgroundColor(Color decorationBackgroundColor) {
        this.decorationBackgroundColor = decorationBackgroundColor;

        if (days != null) {
            for (int dayNumber = 0; dayNumber < DAYS_IN_WEEK; dayNumber++) {
                days[dayNumber].setBackground(decorationBackgroundColor);
            }
        }

        if (weeks != null) {
            for (int i = 0; i < 7; i++) {
                weeks[i].setBackground(decorationBackgroundColor);
            }
        }
    }

    /**
     * Returns the Sunday foreground.
     *
     * @return Color the Sunday foreground.
     */
    public Color getSundayForeground() {
        return sundayForeground;
    }

    /**
     * Returns the weekday foreground.
     *
     * @return Color the weekday foreground.
     */
    public Color getWeekdayForeground() {
        return weekdayForeground;
    }

    /**
     * Sets the Sunday foreground.
     *
     * @param sundayForeground The sundayForeground to set
     */
    public void setSundayForeground(Color sundayForeground) {
        this.sundayForeground = sundayForeground;
        drawDayNames();
        drawDays();
    }

    /**
     * Sets the weekday foreground.
     *
     * @param weekdayForeground The weekdayForeground to set
     */
    public void setWeekdayForeground(Color weekdayForeground) {
        this.weekdayForeground = weekdayForeground;
        drawDayNames();
        drawDays();
    }

    /**
     * Requests that the selected day also have the focus.
     */
    public void setFocus() {
        if (selectedDay != null) {
            this.selectedDay.requestFocus();
        }
    }

    /**
     * The decoration background is the background color of the day titles and
     * the weeks of the year.
     *
     * @return Returns true, if the decoration background is painted.
     */
    public boolean isDecorationBackgroundVisible() {
        return decorationBackgroundVisible;
    }

    /**
     * The decoration background is the background color of the day titles and
     * the weeks of the year.
     *
     * @param decorationBackgroundVisible true, if the decoration background
     * shall be painted.
     */
    public void setDecorationBackgroundVisible(
            boolean decorationBackgroundVisible) {
        this.decorationBackgroundVisible = decorationBackgroundVisible;
        initDecorations();
    }

    /**
     * The decoration border is the button border of the day titles and the
     * weeks of the year.
     *
     * @return Returns true, if the decoration border is painted.
     */
    public boolean isDecorationBordersVisible() {
        return decorationBordersVisible;
    }

    public boolean isDayBordersVisible() {
        return dayBordersVisible;
    }

    /**
     * The decoration border is the button border of the day titles and the
     * weeks of the year.
     *
     * @param decorationBordersVisible true, if the decoration border shall be
     * painted.
     */
    public void setDecorationBordersVisible(boolean decorationBordersVisible) {
        this.decorationBordersVisible = decorationBordersVisible;
        initDecorations();
    }

    public void setDayBordersVisible(boolean dayBordersVisible) {
        this.dayBordersVisible = dayBordersVisible;
        if (initialized) {
            for (int x = 7; x < DAYS_SLOTS; x++) {
                if ("Windows".equals(UIManager.getLookAndFeel().getID())) {
                    days[x].setContentAreaFilled(dayBordersVisible);
                } else {
                    days[x].setContentAreaFilled(true);
                }
                days[x].setBorderPainted(dayBordersVisible);
            }
        }
    }

    /**
     * Updates the UI and sets the day button preferences.
     */
    @Override
    public void updateUI() {
        super.updateUI();
        setFont(Font.decode("Dialog Plain 11"));

        if (weekPanel != null) {
            weekPanel.updateUI();
        }
        if (initialized) {
            if ("Windows".equals(UIManager.getLookAndFeel().getID())) {
                setDayBordersVisible(false);
                setDecorationBackgroundVisible(true);
                setDecorationBordersVisible(false);
            } else {
                setDayBordersVisible(true);
                setDecorationBackgroundVisible(decorationBackgroundVisible);
                setDecorationBordersVisible(decorationBordersVisible);
            }
        }
    }

    /**
     * Sets a valid date range for selectable dates. If max is before min, the
     * default range with no limitation is set.
     *
     * @param min the minimum selectable date or null (then the minimum date is
     * set to 01\01\0001)
     * @param max the maximum selectable date or null (then the maximum date is
     * set to 01\01\9999)
     */
    public void setSelectableDateRange(Date min, Date max) {
//        minMaxDateEvaluator.setMaxSelectableDate(max);
//        minMaxDateEvaluator.setMinSelectableDate(min);

        minSelectableDate = min == null ? defaultMinSelectableDate : min;
        maxSelectableDate = max == null ? defaultMaxSelectableDate : max;
        if (maxSelectableDate.before(minSelectableDate)) {
            minSelectableDate = defaultMinSelectableDate;
            maxSelectableDate = defaultMaxSelectableDate;
        }
        drawDays();
    }

    /**
     * Sets the maximum selectable date. If null, the date 01\01\9999 will be
     * set instead.
     *
     * @param max the maximum selectable date
     *
     * @return the maximum selectable date
     */
    public Date setMaxSelectableDate(Date max) {
//        Date maxSelectableDate = minMaxDateEvaluator.setMaxSelectableDate(max);
        maxSelectableDate = max == null ? defaultMaxSelectableDate : max;
        drawDays();
        return new Date(maxSelectableDate.getTime());
    }

    /**
     * Sets the minimum selectable date. If null, the date 01\01\0001 will be
     * set instead.
     *
     * @param min the minimum selectable date
     *
     * @return the minimum selectable date
     */
    public Date setMinSelectableDate(Date min) {
//        Date minSelectableDate = minMaxDateEvaluator.setMinSelectableDate(min);
        if (min == null) {
            minSelectableDate = defaultMinSelectableDate;
        } else {
            minSelectableDate = new Date(min.getTime());
        }
        drawDays();
        return new Date(minSelectableDate.getTime());
    }

    /**
     * Gets the maximum selectable date.
     *
     * @return the maximum selectable date
     */
    public Date getMaxSelectableDate() {
//        return minMaxDateEvaluator.getMaxSelectableDate();
        return new Date(maxSelectableDate.getTime());
    }

    /**
     * Gets the minimum selectable date.
     *
     * @return the minimum selectable date
     */
    public Date getMinSelectableDate() {
//        return minMaxDateEvaluator.getMinSelectableDate();
        return new Date(minSelectableDate.getTime());
    }

    /**
     * Gets the current {@link DateVerifier}.
     *
     * @return the {@link DateVerifier}, or <code>null</code> if no verifier is
     * established.
     */
    public DateVerifier getDateVerifier() {
        return dateVerifier;
    }

    /**
     * Sets the argument as the {@link DateVerifier} for this chooser. If the
     * argument is <code>null</code> then any existing verifier is removed.
     * <br>
     * <strong>Note:</strong> Validation first takes place against the current
     * <code>minSelectableDate</code> and <code>maxSelectableDate</code>. Only
     * if the date passes these checks is any DateVerifier then invoked.
     *
     * @param dateVerifier The {@link DateVerifier}.
     */
    public void setDateVerifier(DateVerifier dateVerifier) {
        this.dateVerifier = dateVerifier;
        drawDays();
    }

    /**
     * Gets the maximum number of characters of a day name or 0. If 0 is
     * returned, dateFormatSymbols.getShortWeekdays() will be used.
     *
     * @return the maximum number of characters of a day name or 0.
     */
    public int getMaxDayCharacters() {
        return maxDayCharacters;
    }

    /**
     * Sets the maximum number of characters per day in the day bar. Valid
     * values are 0-4. If set to 0, dateFormatSymbols.getShortWeekdays() will be
     * used, otherwise theses strings will be reduced to the maximum number of
     * characters.
     *
     * @param maxDayCharacters the maximum number of characters of a day name.
     */
    public void setMaxDayCharacters(int maxDayCharacters) {
        if (maxDayCharacters == this.maxDayCharacters) {
            return;
        }

        this.maxDayCharacters = maxDayCharacters < 0 || maxDayCharacters > 4 ? 0 : maxDayCharacters;
        drawDayNames();
        drawDays();
        invalidate();
    }

    public void addDateEvaluator(IDateEvaluator dateEvaluator) {
        dateEvaluators.add(dateEvaluator);
    }

    public void removeDateEvaluator(IDateEvaluator dateEvaluator) {
        dateEvaluators.remove(dateEvaluator);
    }

    private void initializeDateEvaluators() {
        dateEvaluators = new ArrayList<>(1);
        minMaxDateEvaluator = new MinMaxDateEvaluator();
        addDateEvaluator(minMaxDateEvaluator);
    }
}
